// 对于不返回值且有一个 double 类型形式参数的函数，下列哪些函数原型是有效的？
// (a) void f (double x);
// (b) void f (double);
// (c) void f (x);
// (d) f (double x);


// 在进行判断之前不妨先把相关的概念再明确一次：
// “为了与过去的那种圆括号内为空的函数声明相区别，我们把正在讨论的这类函数声明称为函数原型（function prototype）。原型为如何调用函数提供了完整的描述：提供了多少实际参数，这些参数应该是什么类型，以及返回的结果是什么类型。”


// （a）
// 提供了 1 个实际参数 x。
// 实际参数 x 应该是 double 类型。
// 返回的结果应该是 void 类型。
// 所以，这个函数原型提供了完整的描述，它是合法的。



// （b）
// 提供了 1 个实际参数 名称省略。
// 实际参数 x 应该是 double 类型。
// 返回的结果应该是 void 类型。
// 名称省略原型中是允许的：
// 9.2 “函数原型不需要说明函数形式参数的名字，只要显示它们的类型就可以了。”
// 所以，这个函数原型提供了完整的描述，它是合法的。


// （c）
// 提供了 1 个实际参数 x。
// 实际参数 x 的类型信息是缺失的。
// 返回的结果应该是 void 类型。
// 所以，这个函数原型缺失了形式参数的类型，对于要调用的函数描述是不完整的，所以它是非法的。


// （d）
// 提供了 1 个实际参数 x。
// 实际参数 x 应该是 double 类型。
// 返回的结果的类型信息缺失了。
// 所以，这个函数原型缺失了返回结果的类型信息，对于要调用的函数描述是不完整的，所以它是非法的。


// 同时，针对缺失了函数声明返回结果的类型信息这一情况，书本上有更加详细阐述：9.1.1（函数定义）如果省略返回类型，C89 会假定函数返回值的类型是 int 类型，但在 C99 中这是不合法的。
// 更加严谨的说，由于本题说明了这是一个不返回值的函数，所以这个函数原型不论在 C89 还是 C99 中都不会达到这个函数原型应该达到的效果。可如果本题改为一个返回值是 int 的函数，这条函数原型是否有可能在 C89 中正常运行呢？
// 为了消除这个疑惑，我用本章练习题 6 的代码做了实验，将以下这条代码中 int 删除，发现程序是可以正常运行的。

// int digit(int , int );
// 更甚者，我将以下函数定义中的 int 也删除后，程序依旧可以正常运行。
// int digit(int number, int wanted_digit)
// {
//   ...
// }

// 当然我们在此不应该模糊了 “是否合法” 与 “能否正常运行” 之间的界限。不论结果如何，我倡议大家能够遵照所学的标准来书写代码。因为遵照标准，不仅仅降低了我们代码出错的概率，更重要的意义在于，标准的存在降低了从事本行业所有人在面对一段代码时的裁决成本。而我们应该做的，就是树立标准，并尊重它。
