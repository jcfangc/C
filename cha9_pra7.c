// 假设函数f有如下定义:
// int f (int a, int b) {...}
// 那么下面哪些语句是合法的？(假设 i 的类型为 int 而 x 的类型为 double。)
// (a) i = f (83,12);
// (b) x = f (83, 12);
// (c) i = f (3.15, 9.28);
// (d) x = f (3.15, 9.28);
// (e) f (83, 12);



// 以下小括号并非强制转换的意思 请注意不要误解。

// (a)
// (int)i = (int)f((int) 83, (int) 12)
// f 的形式参数要求是 int,而实际参数也是 int。
// f 返回的参数类型是 int,被赋值的左值 i 类型也是 int。
// 所以,这个语句应该是合法的。



// (b)
// (double)x = (int)f((int) 83, (int) 12)
// f 的形式参数要求是 int,而实际参数也是 int。
// f 返回的参数类型是 int,被赋值的左值 x 类型却是 double。
// 根据书本 7.4.2 (赋值过程中的转换) 这一小结的描述:右边的表达式转换成左边变量的类型。如果变量的类型至少和表达式的类型一样 “宽” ,那么这种转换将没有任何障碍。
// double 占 8 字节
// int 占 4 字节
// 满足 “变量的类型至少和表达式的类型一样 ‘宽’ ” 的条件,所以 f 返回参数的类型会被转换成 double。
// 变成了 (double)x = (double)f((int) 83, (int) 12)
// 所以 这个语句应该是合法的。



// (c)
// (int)i = (int)f((double)3.15, (double) 9.28)
// f 的形式参数要求是 int,而实际参数却是 double。
// 这里根据 9.3.1 (实际参数的转换)的描述,我们需要分情况讨论。
// 情况一:编译器在调用前遇到原型
// 编译器在调用前遇到原型。就像使用赋值一样, 每个实际参数的值被隐式地转换成相应形式参数的类型。例如,如果把 int 类型的实际参数传递给期望得到 double 类型数据的函数,那么实际参数会被自动转换成 double 类型。
// 在本题中,我们是将 double 的实际参数传递给 int 的形式参数。而传递的过程就是 “调用函数时,计算出每个实际参数的值并且把它赋值给相应的形式参数。” 而将 double 类型赋值给 int 类型,首先,根据 7.4.2 “把浮点数赋值给整型变量会丢掉该数的小数部分”,其次, “把某种类型的值赋给类型更狭小的变量时,如果该值在变量类型之外,那么将会得到无意义的结果(甚至更遭)”。
// 所以在这种情况下,i 最终不会得到我们想要的赋值结果,语句是不合法的。
// 情况二:编译器在调用前没有遇到原型
// 编译器执行默认的实际参数提升: (1) 把 float 类型的实际参数转换成 double 类型,(2) 执行整值提升,即把 char 类型和 short 类型的实际参数转换成 int 类型。(C99实现了整数提升。)
// 本题中 两个实际参数本就是 double 类型,这里的提升应该不会起到什么效果,在之后就是将 double 类型实际参数传递给 int 形式参数,结果应该与情况一无异。
// 综上,不论编译器是否在函数调用前遇到了函数原型,最终 i 都不会产生我们希望的赋值结果,所以本语句是非法的。



// (d)
// 尽管根据(b)中的解析,f 返回参数的类型会被转换成 double,并顺利赋值给 double 类型的 x。但是参看 (c)中的解析可以得知,f 首先会因为实际参数没能顺利传递给形式参数,而大概率产生错误的运算结果。错误的结果再正确的赋值到 x 上,其实并没有意义。
// 所以,这个语句应该是非法的。



// (e)
// (int)f ((int) 83, (int) 12)
// f 的形式参数要求是 int,而实际参数也是 int。
// f 最后运算出正确的结果。
// 所以尽管没有意义,本条语句是合法的。