### 如果 i 是 int 类型变量，且 p 和 q 是指向 int 的指针，那么下列哪些赋值是合法的？
***

(a) p = i;&nbsp;&nbsp;&nbsp;&nbsp;(b) *p = &i;&nbsp;&nbsp;&nbsp;&nbsp;(c) &p = q;

(d) p = &q;&nbsp;&nbsp;&nbsp;&nbsp;(e) p = *&p;&nbsp;&nbsp;&nbsp;&nbsp;(f) p = q;

(g) p = *q;&nbsp;&nbsp;&nbsp;&nbsp;(h) *p = q;&nbsp;&nbsp;&nbsp;&nbsp;(i) *p = *q;

***

<br>

|参考答案：|
|:-|
|(a) p = i 相当于直接修改了 p 指向的内存地址，此时 p 指向的内存单元被重新赋值；如果该内存地址属于该程序就会导致不规律的行为，如果属于操作系统，那么很有可能导致系统崩溃。语句不合法。|
|(b) *p = &i 翻译一下就是把指向 i 的指针赋值给 p 的原始变量，p 的原始变量不是指针，这条语句应该达不到我们想要达到的效果。结论是不合法。然而值得注意的是，如果写作这样的初始化式 int *p = &i;，则需要做出区别。|
|(c) &p = q 就是把指针 q 所指向的地址赋值给，形成的指向 p 的指针。指针赋值给指针乍看好像没有问题。但是在编译器中尝试，会出现一个错误警告：表达式必须是可修改的左值。换言之 “&p” 是不可修改的。原因应该是在声明了 p 之后，p 在内存中的地址已经确定下来，即 &p。而显然一个定值是无法被赋予其他的值的。所以这个语句并不合法。|
|(d) p = &q 意思是指向 q 的指针赋值给 p。语句可以通过编译，但是另外通过网上查阅资料发现，要存储指针的指针则要求用来储存的变量类型应该是指针的指针。所以这条语句应该是不合法的。|
|(e) p = *&p 是将指针 p 形成一个指向自身的指针后在通过间接寻址求出该指针的原始变量，也就是 p 本身，最后赋值给 p。语句合法。|
|(f) p = q 是将 q 指针所指的地址赋值给指针 p。语句合法。|
|(g) p = *q 说明用 q 指针找到其指向的原始变量，再把其赋值给指针 p。这里的原始变量显然不是指针，所以本题的情形和（a）很相似，容易造成不好的后果。语句不合法。|
|(h) *p = q 是把 q 指针赋值给 p 指针的原始变量。显然 p 指针的原始变量不是指针类型的变量，语句不合法。|
|(i) *p = *q 是把指针 q 的原始变量赋值给指针 p 的原始变量。p 和 q 都是指向 int 类型的指针，即其原始变量都是 int 类型的，语句合法。|